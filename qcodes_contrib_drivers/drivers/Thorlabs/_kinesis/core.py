from __future__ import annotations

import abc
import ctypes
import os
import pathlib
import time
import warnings
from typing import Mapping, Any, List, Tuple, Iterable

import numpy as np

from qcodes import Instrument
from . import enums

_DLL_DIR = r"C:\Program Files\Thorlabs\Kinesis"


class ThorlabsKinesis:
    _ERROR_CODES = {
        # Errors generated from the FTDI communications module or
        # supporting code
        0: 'FT_OK',
        1: 'FT_InvalidHandle',
        2: 'FT_DeviceNotFound',
        3: 'FT_DeviceNotOpened',
        4: 'FT_IOError',
        5: 'FT_InsufficientResources',
        6: 'FT_InvalidParameter',
        7: 'FT_DeviceNotPresent',
        8: 'FT_IncorrectDevice',
        # Errors generated by the device libraries
        16: 'FT_NoDLLLoaded',
        17: 'FT_NoFunctionsAvailable',
        18: 'FT_FunctionNotAvailable',
        19: 'FT_BadFunctionPointer',
        20: 'FT_GenericFunctionFail',
        21: 'FT_SpecificFunctionFail',
        # General errors generated by all DLLs
        0x20: 'TL_ALREADY_OPEN',
        0x21: 'TL_NO_RESPONSE',
        0x22: 'TL_NOT_IMPLEMENTED',
        0x23: 'TL_FAULT_REPORTED',
        0x24: 'TL_INVALID_OPERATION',
        0x28: 'TL_DISCONNECTING',
        0x29: 'TL_FIRMWARE_BUG',
        0x2A: 'TL_INITIALIZATION_FAILURE',
        0x2B: 'TL_INVALID_CHANNEL',
        # Motor-specific errors generated by the Motor DLLs
        0x25: 'TL_UNHOMED',
        0x26: 'TL_INVALID_POSITION',
        0x27: 'TL_INVALID_VELOCITY_PARAMETER',
        0x2C: 'TL_CANNOT_HOME_DEVICE',
        0x2D: 'TL_JOG_CONTINUOUS_MODE',
        0x2E: 'TL_NO_MOTOR_INFO',
        0x2F: 'TL_CMD_TEMP_UNAVAILABLE'
    }

    _ERROR_MESSAGES = {
        'FT_OK': 'Success',
        'FT_InvalidHandle': 'The FTDI functions have not been initialized.',
        'FT_DeviceNotFound': 'The Device could not be found. This can be '
                             'generated if the function TLI_BuildDeviceList() '
                             'has not been called.',
        'FT_DeviceNotOpened': 'The Device must be opened before it can be '
                              'accessed. See the appropriate Open function '
                              'for your device.',
        'FT_IOError': 'An I/O Error has occured in the FTDI chip.',
        'FT_InsufficientResources': 'There are Insufficient resources to run '
                                    'this application.',
        'FT_InvalidParameter': 'An invalid parameter has been supplied to the '
                               'device.',
        'FT_DeviceNotPresent': 'The Device is no longer present. The device '
                               'may have been disconnected since the last '
                               'TLI_BuildDeviceList() call.',
        'FT_IncorrectDevice': 'The device detected does not match that '
                              'expected.',
        'FT_NoDLLLoaded': 'The library for this device could not be found.',
        'FT_NoFunctionsAvailable': 'No functions available for this device.',
        'FT_FunctionNotAvailable': 'The function is not available for this '
                                   'device.',
        'FT_BadFunctionPointer': 'Bad function pointer detected.',
        'FT_GenericFunctionFail': 'The function failed to complete '
                                  'succesfully.',
        'FT_SpecificFunctionFail': 'The function failed to complete '
                                   'succesfully',
        'TL_ALREADY_OPEN': 'Attempt to open a device that was already open.',
        'TL_NO_RESPONSE': 'The device has stopped responding.',
        'TL_NOT_IMPLEMENTED': 'This function has not been implemented.',
        'TL_FAULT_REPORTED': 'The device has reported a fault.',
        'TL_INVALID_OPERATION': 'The function could not be completed at this '
                                'time.',
        'TL_DISCONNECTING': 'The function could not be completed because the '
                            'device is disconnected.',
        'TL_FIRMWARE_BUG': 'The firmware has thrown an error.',
        'TL_INITIALIZATION_FAILURE': 'The device has failed to initialize.',
        'TL_INVALID_CHANNEL': 'An Invalid channel address was supplied.',
        'TL_UNHOMED': 'The device cannot perform this function until it has '
                      'been Homed.',
        'TL_INVALID_POSITION': 'The function cannot be performed as it would '
                               'result in an illegal position.',
        'TL_INVALID_VELOCITY_PARAMETER': 'An invalid velocity parameter was '
                                         'supplied. The velocity must be '
                                         'greater than zero.',
        'TL_CANNOT_HOME_DEVICE': 'This device does not support Homing. Check '
                                 'the Limit switch parameters are correct.',
        'TL_JOG_CONTINOUS_MODE': 'An invalid jog mode was supplied for the '
                                 'jog function.',
        'TL_NO_MOTOR_INFO': 'There is no Motor Parameters available to '
                            'convert Real World Units.',
        'TL_CMD_TEMP_UNAVAILABLE': 'Command temporarily unavailable, Device '
                                   'may be busy.'
    }

    def __init__(self, lib: str, prefix: str,
                 dll_dir: str | os.PathLike | None = None):
        self.dll_dir = os.add_dll_directory(dll_dir or _DLL_DIR)

        if not lib.startswith("Thorlabs.MotionControl"):
            lib = "Thorlabs.MotionControl." + lib
        if not lib.endswith(".dll"):
            lib = lib + ".dll"
        lib = pathlib.Path(lib)
        if not (dll := (self.dll_dir.path / lib)).exists():
            raise FileNotFoundError(f'Did not find DLL {dll}')

        self.lib: ctypes.CDLL = ctypes.cdll.LoadLibrary(str(lib))
        self.error_check(self.lib.TLI_BuildDeviceList())

        self.prefix = prefix
        self.serialNo = ctypes.c_char_p()

    def __del__(self):
        self.dll_dir.close()

    @classmethod
    def error_check(cls, code: int):
        if (status := cls._ERROR_CODES.get(code)) != 'FT_OK':
            raise KinesisError(f'{status}: {cls._ERROR_MESSAGES[status]}')

    @staticmethod
    def parse_fw_version(fw: int) -> str:
        parts = [f'{i:02d}' for i in fw.to_bytes(length=4, byteorder='big')]
        return '.'.join(parts).lstrip('0.')

    def request_status(self):
        self.error_check(
            getattr(self.lib, f'{self.prefix}_RequestStatus')(self.serialNo)
        )

    def get_position(self) -> int | float | str:
        self.request_status()
        time.sleep(self.get_polling_duration() * 1e-3)
        return getattr(self.lib, f'{self.prefix}_GetPosition')(self.serialNo)

    def set_position(self, val: int | str):
        self.error_check(getattr(self.lib, f'{self.prefix}_MoveToPosition')(
            self.serialNo, val
        ))

    def start_polling(self, duration: int):
        success = getattr(self.lib, f'{self.prefix}_StartPolling')(
            self.serialNo, duration
        )
        if not success:
            raise KinesisError('Failed')

    def stop_polling(self):
        getattr(self.lib, f'{self.prefix}_StopPolling')(self.serialNo)

    def get_polling_duration(self) -> int:
        return getattr(self.lib, f'{self.prefix}_PollingDuration')(self.serialNo)

    def set_polling_duration(self, duration: int):
        self.stop_polling()
        self.start_polling(duration)

    def connect(self, polling_duration: int = 100):
        self.error_check(
            getattr(self.lib, f'{self.prefix}_Open')(self.serialNo)
        )

    def disconnect(self):
        getattr(self.lib, f'{self.prefix}_Close')(self.serialNo)

    def get_hw_info(self) -> Tuple[str, int, int, str, str, int, int]:
        modelNo = ctypes.create_string_buffer(64)
        type = ctypes.wintypes.WORD()
        numChannels = ctypes.wintypes.WORD()
        notes = ctypes.create_string_buffer(64)
        firmwareVersion = ctypes.wintypes.DWORD()
        hardwareVersion = ctypes.wintypes.WORD()
        modificationState = ctypes.wintypes.WORD()
        self.error_check(
            getattr(self.lib, f'{self.prefix}_GetHardwareInfo')(
                self.serialNo,
                modelNo, 64,
                ctypes.byref(type),
                ctypes.byref(numChannels),
                notes, 64,
                ctypes.byref(firmwareVersion),
                ctypes.byref(hardwareVersion),
                ctypes.byref(modificationState)
            )
        )
        return (modelNo.value.decode('utf-8'),
                type.value,
                numChannels.value,
                notes.value.decode('utf-8'),
                self.parse_fw_version(firmwareVersion.value),
                hardwareVersion.value,
                modificationState.value)


class KinesisInstrument(Instrument, metaclass=abc.ABCMeta):
    def __init__(self, name: str, dll_dir: str | pathlib.Path | None = None,
                 metadata: Mapping[Any, Any] | None = None,
                 label: str | None = None):
        try:
            self.kinesis = ThorlabsKinesis(self.hardware_type.name, self._prefix, dll_dir)
        except FileNotFoundError:
            # Subclass needs to handle irregular dll name
            pass

        super().__init__(name, metadata, label)

        self.add_parameter('polling_duration',
                           get_cmd=self.kinesis.get_polling_duration,
                           set_cmd=self.kinesis.set_polling_duration,
                           unit='ms')

    @classmethod
    @property
    @abc.abstractmethod
    def _prefix(cls) -> str:
        pass

    @classmethod
    @property
    @abc.abstractmethod
    def hardware_type(cls) -> enums.KinesisHWType:
        pass

    @property
    def serial(self) -> int | None:
        sn = self.kinesis.serialNo.value
        if sn is not None:
            return int(sn.decode())
        return None

    def list_available_devices(self) -> List[int]:
        return [serial for _, serial in
                list_available_devices(self.kinesis.lib, self.hardware_type)]

    def connect(self, serial: int, polling_duration: int = 100):
        if self.serial is not None:
            warnings.warn('Already connected to  device with serial '
                          f'{self.serial}. Disconnecting.',
                          UserWarning, stacklevel=2)
            self.disconnect()

        try:
            old_serial_value = self.kinesis.serialNo.value
            self.kinesis.serialNo.value = str(serial).encode()
            self.kinesis.connect()
        except KinesisError:
            self.kinesis.serialNo.value = old_serial_value
            raise
        self.kinesis.start_polling(polling_duration)
        self.connect_message()

    def disconnect(self):
        self.kinesis.stop_polling()
        self.kinesis.disconnect()
        self.kinesis.serialNo.value = None

    def get_idn(self) -> dict[str, str]:
        model, type, num_channels, notes, firmware, hardware, state = \
            self.kinesis.get_hw_info()
        return {'vendor': 'Thorlabs', 'model': model, 'firmware': firmware,
                'serial': self.serial}

    def close(self):
        self.disconnect()
        super().close()


class KinesisError(Exception):
    """An error raised by a Kinesis DLL."""


def list_available_devices(
        lib: str | pathlib.Path | ctypes.CDLL | None = None,
        hardware_type: Iterable[enums.KinesisHWType] | enums.KinesisHWType | None = None
) -> List[Tuple[enums.KinesisHWType, int]]:
    if not isinstance(lib, ctypes.CDLL):
        # Open base directory
        if lib is None:
            lib = _DLL_DIR
        lib = pathlib.Path(lib)
        if lib.is_file():
            lib = lib.parent
        lib = os.add_dll_directory(str(lib))
        lib = ctypes.cdll.LoadLibrary(str(pathlib.Path(
            lib.path,
            'Thorlabs.MotionControl.DeviceManager.dll'
        )))

    ThorlabsKinesis.error_check(lib.TLI_BuildDeviceList())
    n: int = lib.TLI_GetDeviceListSize()

    devices = []
    hw_type_list = []
    if hardware_type is not None:
        # Only search for devices of the passed hardware type (model)
        if not np.iterable(hardware_type):
            hardware_type = [hardware_type]
        for hw in hardware_type:
            hw_type_list.append(hw.value)
    else:
        # Search for all models
        hw_type_list = list(range(1, 101))

    for hw_type_id in hw_type_list:
        # char array, 8 bytes for serial number, 1 for delimiter, plus 1
        # surplus needed apparently
        serialNo = (ctypes.c_char * (9 + 1))()

        ThorlabsKinesis.error_check(lib.TLI_GetDeviceListByTypeExt(
            ctypes.byref(serialNo),
            ctypes.wintypes.DWORD(9 + 1),
            hw_type_id
        ))
        if serialNo.value:
            devices.append((enums.KinesisHWType(hw_type_id), int(serialNo.value.rstrip(b','))))
        if len(devices) == n:
            # Found all devices already
            break

    return devices
